"""
CodeSandbox Integration for Devo AI
This module handles the integration with CodeSandbox SDK for creating and managing sandboxes.
"""

import os
import asyncio
import aiohttp
import json
from typing import Dict, Optional, List
import streamlit as st

class CodeSandboxManager:
    """Enhanced CodeSandbox integration with full SDK support"""
    
    def __init__(self):
        self.api_key = os.getenv("CSB_API_KEY")
        self.base_url = "https://api.codesandbox.io/v1"
        
        if not self.api_key:
            st.warning("CSB_API_KEY not found. Sandbox features will be limited.")
    
    async def create_sandbox(self, files: Dict[str, str], template: str = "vanilla") -> Optional[str]:
        """
        Create a new CodeSandbox with the provided files
        
        Args:
            files: Dictionary of filename -> file content
            template: Base template to use (vanilla, react, vue, etc.)
        
        Returns:
            Sandbox ID if successful, None otherwise
        """
        if not self.api_key:
            return None
        
        try:
            headers = {
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json"
            }
            
            # Prepare the sandbox configuration
            sandbox_config = {
                "files": self._format_files_for_api(files),
                "template": template,
                "title": "Devo AI Generated App",
                "description": "Generated by Devo AI",
                "tags": ["devo-ai", "generated", "auto-created"]
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    f"{self.base_url}/sandboxes",
                    headers=headers,
                    json=sandbox_config
                ) as response:
                    if response.status == 201:
                        result = await response.json()
                        return result.get("id")
                    else:
                        error_text = await response.text()
                        st.error(f"CodeSandbox API Error: {response.status} - {error_text}")
                        return None
        
        except Exception as e:
            st.error(f"Error creating sandbox: {e}")
            return None
    
    async def update_sandbox(self, sandbox_id: str, files: Dict[str, str]) -> bool:
        """
        Update an existing sandbox with new files
        
        Args:
            sandbox_id: ID of the sandbox to update
            files: New files to upload
        
        Returns:
            True if successful, False otherwise
        """
        if not self.api_key:
            return False
        
        try:
            headers = {
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json"
            }
            
            update_data = {
                "files": self._format_files_for_api(files)
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.patch(
                    f"{self.base_url}/sandboxes/{sandbox_id}",
                    headers=headers,
                    json=update_data
                ) as response:
                    return response.status == 200
        
        except Exception as e:
            st.error(f"Error updating sandbox: {e}")
            return False
    
    async def get_sandbox_info(self, sandbox_id: str) -> Optional[Dict]:
        """Get information about a sandbox"""
        if not self.api_key:
            return None
        
        try:
            headers = {
                "Authorization": f"Bearer {self.api_key}"
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    f"{self.base_url}/sandboxes/{sandbox_id}",
                    headers=headers
                ) as response:
                    if response.status == 200:
                        return await response.json()
                    return None
        
        except Exception as e:
            st.error(f"Error getting sandbox info: {e}")
            return None
    
    def _format_files_for_api(self, files: Dict[str, str]) -> Dict:
        """Format files for CodeSandbox API"""
        formatted_files = {}
        
        for filename, content in files.items():
            formatted_files[filename] = {
                "content": content,
                "isBinary": False
            }
        
        return formatted_files
    
    def get_sandbox_url(self, sandbox_id: str) -> str:
        """Get the public URL for a sandbox"""
        return f"https://codesandbox.io/s/{sandbox_id}"
    
    def get_embed_url(self, sandbox_id: str) -> str:
        """Get the embed URL for a sandbox"""
        return f"https://codesandbox.io/embed/{sandbox_id}"

class AdvancedSandboxFeatures:
    """Advanced features for sandbox management"""
    
    def __init__(self, sandbox_manager: CodeSandboxManager):
        self.sandbox_manager = sandbox_manager
    
    async def run_command_in_sandbox(self, sandbox_id: str, command: str) -> Optional[str]:
        """
        Execute a command in the sandbox (requires CodeSandbox Pro)
        
        Args:
            sandbox_id: Target sandbox ID
            command: Command to execute
        
        Returns:
            Command output if successful
        """
        # This would use CodeSandbox's VM execution API
        # Implementation depends on CodeSandbox SDK features
        pass
    
    async def install_npm_packages(self, sandbox_id: str, packages: List[str]) -> bool:
        """Install NPM packages in the sandbox"""
        command = f"npm install {' '.join(packages)}"
        result = await self.run_command_in_sandbox(sandbox_id, command)
        return result is not None
    
    async def build_project(self, sandbox_id: str) -> bool:
        """Build the project in the sandbox"""
        result = await self.run_command_in_sandbox(sandbox_id, "npm run build")
        return result is not None
    
    async def run_tests(self, sandbox_id: str) -> Optional[str]:
        """Run tests in the sandbox"""
        return await self.run_command_in_sandbox(sandbox_id, "npm test")

# Utility functions for Streamlit integration
def create_sandbox_async(files: Dict[str, str], template: str = "vanilla") -> Optional[str]:
    """Wrapper function for creating sandbox from Streamlit"""
    manager = CodeSandboxManager()
    
    async def _create():
        return await manager.create_sandbox(files, template)
    
    # Run async function
