import os
import zipfile
from io import BytesIO
import streamlit as st
from google import genai
from google.genai import types
from dotenv import load_dotenv
import requests

load_dotenv()

# Gemini API Full App Generation
def generate_full_app_code(prompt, language):
    client = genai.Client(api_key=os.getenv("GEMINI_API_KEY"))
    model = "gemini-2.5-flash"
    contents = [
        types.Content(
            role="user",
            parts=[types.Part.from_text(text=f"Generate a full production-ready {language} application project based on this description: {prompt}. Include all necessary files, Docker configuration, tests, deployment scripts, and Supabase integration (edge functions, database, auth).")],
        )
    ]
    generate_content_config = types.GenerateContentConfig(
        temperature=1,
        max_output_tokens=65535,
        thinking_config=types.ThinkingConfig(thinking_budget=0),
    )
    
    full_code = ""
    for chunk in client.models.generate_content_stream(
        model=model,
        contents=contents,
        config=generate_content_config,
    ):
        if chunk.text:
            full_code += chunk.text
    return full_code

# ZIP the generated project
def create_zip_from_code(code_text):
    zip_buffer = BytesIO()
    with zipfile.ZipFile(zip_buffer, 'w') as zip_file:
        zip_file.writestr("project_generated/README.md", "# Generated Application\nThis project was generated by Gemini API.")
        zip_file.writestr("project_generated/app_description.txt", code_text)
        zip_file.writestr("project_generated/Dockerfile", """
FROM python:3.9-slim
WORKDIR /app
COPY . /app
RUN pip install -r requirements.txt
CMD ["python", "main.py"]
        """)
    zip_buffer.seek(0)
    return zip_buffer

# Extract uploaded ZIP file
def handle_zip_upload(uploaded_file):
    upload_dir = "uploaded_files"
    os.makedirs(upload_dir, exist_ok=True)
    with zipfile.ZipFile(uploaded_file, 'r') as zip_ref:
        zip_ref.extractall(upload_dir)
    return upload_dir

# Deploy Edge Function to Supabase
def deploy_supabase_edge_function(supabase_url, supabase_key, function_name, code_text):
    url = f"{supabase_url}/functions/v1/{function_name}"
    headers = {
        "apikey": supabase_key,
        "Authorization": f"Bearer {supabase_key}",
        "Content-Type": "application/json",
    }
    payload = {
        "name": function_name,
        "code": code_text
    }
    try:
        response = requests.post(url, json=payload, headers=headers)
        if response.status_code in [200, 201]:
            return True, "‚úÖ Edge function deployed successfully."
        else:
            return False, f"‚ùå Deployment failed: {response.text}"
    except Exception as e:
        return False, f"‚ö†Ô∏è Error deploying function: {str(e)}"

# Streamlit Chatbot Interface
def main():
    st.set_page_config(page_title="Gemini + Supabase App Generator", layout="wide")

    st.title("üöÄ Gemini + Supabase End-to-End Application Generator with Edge Functions")

    # Supabase Configuration Inputs
    st.sidebar.header("Supabase Configuration")
    supabase_url = st.sidebar.text_input("Supabase URL", value="")
    supabase_key = st.sidebar.text_input("Supabase API Key", type="password")

    language = st.selectbox(
        "Select Target Programming Language",
        ["Python", "TypeScript", "Java", "C++", "Ruby"]
    )

    user_prompt = st.text_area(
        "Describe your full application requirement in detail (including DB, auth, edge functions):",
        height=200
    )

    if st.button("üí° Generate Full App Code"):
        if not user_prompt.strip() or not supabase_url or not supabase_key:
            st.error("‚ö†Ô∏è Supabase URL, API Key, and description are required.")
            return

        with st.spinner("‚è≥ Generating full production-ready code..."):
            try:
                generated_code = generate_full_app_code(user_prompt, language)
                st.subheader("‚úÖ Generated Application Code Preview:")
                st.code(generated_code, language="python")

                zip_file = create_zip_from_code(generated_code)
                st.download_button(
                    label="üì• Download Complete Application as ZIP",
                    data=zip_file,
                    file_name="generated_app.zip",
                    mime="application/zip"
                )
                st.success("üéâ Application generated successfully.")

                # Deploy edge function automatically
                function_name = "generated_edge_function"
                success, message = deploy_supabase_edge_function(
                    supabase_url, supabase_key, function_name, generated_code
                )
                if success:
                    st.success(message)
                else:
                    st.error(message)

            except Exception as e:
                st.error(f"‚ö†Ô∏è An error occurred: {str(e)}")

    st.markdown("---")

    uploaded_file = st.file_uploader("üìÇ Upload existing project ZIP", type="zip")
    if uploaded_file:
        try:
            extracted_path = handle_zip_upload(uploaded_file)
            st.success(f"‚úÖ Uploaded and extracted files to `{extracted_path}`.")

            # Only deploy if app_description.txt exists
            desc_file_path = os.path.join(extracted_path, "app_description.txt")
            if os.path.exists(desc_file_path) and supabase_url and supabase_key:
                with open(desc_file_path, "r") as desc_file:
                    code_text = desc_file.read()

                function_name = "uploaded_edge_function"
                success, message = deploy_supabase_edge_function(
                    supabase_url, supabase_key, function_name, code_text
                )
                if success:
                    st.success(message)
                else:
                    st.error(message)
            else:
                st.info("‚ÑπÔ∏è No `app_description.txt` found; skipping edge function deployment.")

        except Exception as e:
            st.error(f"‚ö†Ô∏è Upload/Extraction failed: {str(e)}")

if __name__ == "__main__":
    main()
